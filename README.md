# Walk On Spheres

Walkonspheres is a package for solving Poisson's equation with no boundary term :

$$ \Delta u(x) = f(x) \quad \forall x \in \Omega$$

$$ u(x) = 0 \qquad \quad \forall x \in \partial \Omega$$

with $f$ the source term inside the domain $\Omega$, with $\partial \Omega$ it's boundary.

This equation can represent magnetostatic problems, electrostatics, heat... Usually these problems have a structure that radiates a energy. The package is meant to take into account any type of geometry as the source of radiation, with an interface described below.

The package uses pybind11 C++ interce with python, NVIDIA's Warp library to write CUDA kernels, and polyscope for visualization.

# Exemples
Figures below illustrate the magnetic vector potential and potential computed and visualized with the package (left and right). The geometry's mesh that generated those data is shown at the center. It represents wires, organized in a toroidal shape, carrying current creating a magnetic field, from wich we compute the potential vector.

| <img src="figures/transfo_full.png" width="900"/> | <img src="figures/solenoid.png" width="860"/> | <img src="figures/transfo_field.png" width="915"/> |
| ------------------------- | ------------------------- | ------------------------------ |

The figure below shows the potential magnetic vector field from a current loop :
![](figures/loop.png)

The next exemple is the field generated by a solenoid :

| <img src="figures/solenoid_field.png" width="1065"/> | <img src="figures/solenoid_grasshopper.png" width="860"/> |
| ------------------------------ | ------------------------------ |


# The Walk On Spheres algorithm

We use in this package the said *reverse* walk on spheres algorithm (Qi et al.). The main concept is the following : a walk on sphere is a random walk from which the steps are taken on the biggest sphere contained in the domain $\Omega$. An illustration of a walk on sphere :

![OneWalk](figures/onewalk.png)

The walk needs at each step to know the distance from a point and the domain $\Omega$. Since in the problems we solve in this package, the domains $\Omega$ are simply defined by the fact that we want the solution to be zero at infinity, we set the domain to be a sphere a radius big enough to represent this infinity. Then to get the distance of a point on the walk from the domain, we simply compute :

$$ distance = R_{\infty} - \sqrt{x^2 + y^2 + z^2} $$

The *reverse* walk on spheres starts walks from the source and propagates it's values, so we have to know where the source is inside the domain. Usually it's represent by a mesh, or some kind of geometry. The algorithm will take a point on that geometry, the source value corresponding, and propagates it's value inside the domain.

This package is meant so we don't have to assume the geometry is represented a mesh. Indeed, in the algorithm, we only need some source points and values. Those points are to be generated by the user.

Structures representing sources can be quite complex (a network of wires would for example need a high precision mesh, expensive to compute). The only need for points make so that the user don't necessarily have to compute the mesh : if he has an implicit geometry, a CAO geometry, etc... He just have to generate points from that structure, and give the package those points.

# Inverse Problems
This package is an answer to difficulties encountered in inverse problems on geometry. Finding the right parameters on complex geometry can be costly since we, at each step, need to regenerate the mesh, a step that can take hours for complex structures.

Here we have a pipeline that can solve the direct problem without generating any mesh. This can be used in black box optimization tools.

# Installation
Once you made sure you have CUDA Toolkit and a C++ compiler installed, just go in the folder and write :
```
pip install .
```

# Usage
Once it's installed, the steps are the following (full examples can be seen in the examples folder) :

Load the library (python and c++ are disjointed)
```py
import walkonspheres as ws
```

Create the object holding solver and setup methods
```py
pde = ws.PoissonSolver()
```

Set parameters : `nwalks` corresponds to the number of information to gather, and is basically the number of Monte Carlo steps in the simulation, so it will define the precision of the results ; `sdfR` is the radius of the "infinite" sphere domain as described above ; the solution dimension can be 1 (scalar field) or 3 (3D vector field)
```py
pde.set_nwalks(10000)
pde.set_sdfR(400.0)
pde.set_solution_dimension(1)
```

The `query_points` corresponds to the points where we search the solution. It's usually a grid, but we might want to set those points to a specific location
```py
pde.set_query_points(point_array)
```
we provide a tool to get a grid easily :
```py
lower_corner = [-170.0,-170.0,-170.0] # Lower corner grid delimiter
upper_corner = [170.0,170.0,170.0]    # Upper corner grid delimiter
n = 30   # Solution grid dim
query_points = ws.create_grid_query_pts(lower_corner, upper_corner, n)
```

Source points are the points coming from the source structure. It can be built by a python function of yours, describing a certain parametrized geometry, or it can come from a file
```py
pde.set_source_points(source_points)
```
a tool to initialize those points from a file is also given (each line of the file should contain the 3 coordinates of a point, with ',' delimiters) :
```py
ws.read_pts_from_file("assets/meshpts.dat")
```

The source values/vectors, that needs to match the source points, can be sent one of 4 ways :
```py
pde.set_source_value(1.0)
pde.set_source_values(values_array)
pde.set_source_vector([1.0,1.0,1.0])
pde.set_source_vectors(vectors_array)
```
the value keyword corresponds to the 1D (scalar field) case, the vector to vector fields. You can set the same value for every point (singular version), or directly set the array yourself (plural version). You can also create this array by reading a file.

Call this function to get the solution
```py
pde.solve()
```

And finally visualize it (adding a mesh visualization can help understand the situation):
```py
pde.plot("assets/mesh.stl")
pde.plot_with_mesh("assets/mesh.stl")
```

# Visualization

![Polyscope](figures/polyscope.png)

A couple of useful tips to help the visualization with polyscope :
- By default, a slice plane is created. You can remove it in the "Polyscope->View->Slice Plances" by unchecking it. You can also display the draw plane and draw widget to move it, or create a new one.
- In the structures part, if it's a vector field, there should be :
  - the `Solution query points`, where the radius will define the size of the squares. For the colors of those to be the magnitude of the computed field, you have to check the "Enabled" box.
  - the `Solution (vector)` where you can change the length and radius of the vectors

# Bibliography
Qi, Yang, Dario Seyb, Benedikt Bitterli, et Wojciech Jarosz. « A Bidirectional Formulation for Walk on Spheres ». Computer Graphics Forum 41, nᵒ 4 (juillet 2022): 51‑62. https://doi.org/10.1111/cgf.14586.